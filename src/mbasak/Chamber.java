package mbasak;

import dnd.die.D20;
import dnd.exceptions.NotProtectedException;
import dnd.exceptions.UnusualShapeException;
import dnd.models.ChamberContents;
import dnd.models.ChamberShape;
import dnd.models.Monster;
import dnd.models.Exit;
import dnd.models.Stairs;
import dnd.models.Trap;
import dnd.models.Treasure;

import java.util.ArrayList;

public class Chamber extends Space {

    /**Contains the description of chamber's contents.*/
    private ChamberContents myContents;
    /**Contains the description of chamber's shape and size.*/
    private ChamberShape chamberShapeSize;
    /**Contains the treasure in the chamber.*/
    private Treasure myTreasure;
//    private ArrayList<Treasure> myTreasure;
    /**Contains monster the chamber contains.*/
//    private ArrayList<Monster> myMonsters;
    private Monster myMonster;
    /**Contains all the exits that the chamber contains.*/
    private ArrayList<Exit> myExits;
    /**Contains all the doors the chamber contains.*/
    private ArrayList<Door> myDoors;
    /**Contains the string description of the shape and size of the chamber that's generated.*/
    private String shapeAndSizeGenString;
    /**Contains the string description of the contents of the chamber that's generated.*/
    private String chamberContentsDescString;
    /**Instance D20 roll.*/
    private D20 d20;
    /**This variable assigns chamber position in sorted list.*/
    private int index;

    /*-----------------------------
     Required Methods for that we will test during grading
    ------------------------------*/
    /* note:  Some of these methods would normally be protected or private, but because we
    don't want to dictate how you set up your packages we need them to be public
    for the purposes of running an automated test suite (junit) on your code.  */

    /**Constructor that initializes all the variables needed when object is first created.*/
    public Chamber() {
        d20 = new D20();

        // Contents setup
        myContents = new ChamberContents();
        myContents.chooseContents(d20.roll());
        setContents(myContents);

        // Chamber shape and size setup
        setShape(ChamberShape.selectChamberShape(d20.roll()));

        myDoors = new ArrayList<>();

        setDescription();
    }

//    /**Constructor that sets the shape and contents instance variables.
//     * @param theShape Generate chamber's shape based on passed shape object.
//     * @param theContents Generate chamber's contents based on passed contents object.*/
//    public Chamber(ChamberShape theShape, ChamberContents theContents) {
//        setShape(theShape);
//        setContents(theContents);
//
//        myDoors = new ArrayList<>();
//
//        setDescription();
//    }

    /**This method inserts the position number of the chamber in the list from main.
     * @param i Integer position of chamber.*/
    public void setIndex(int i) {

        index = i;
    }

    /**This method retrieves the position number of the chamber number in the list from main.
     * @return Integer position number of chamber.*/
    public int getIndex() {

        return index;
    }

    /** This function sets the shape and size of the chamber based on passed object.
     * @param theShape The shape and size object that describes part of the chamber.*/
    private void setShape(ChamberShape theShape) {

        chamberShapeSize = theShape;
    }

    /** This function sets the shape and size of the chamber based on passed object.
     * @param theContents Object sets the contents instance variable for the chamber.*/
    private void setContents(ChamberContents theContents) {

        myContents = theContents;
    }

    /**This function retrieves the doors that's in the chamber.
     * @return This returns an ArrayList which contains all the doors in the chamber.*/
    public ArrayList<Door> getDoors() { // Basically for other classes to access

        return myDoors;
    }

    /**This function adds the monster that was generated by the chamber.
     * @param theMonster This is the monster object that is generated in chamber contents.*/
    private void addMonster(Monster theMonster) {

        myMonster = theMonster; // Only allow one monster for this assignment
    }

    /**This function retrieves the monsters that's in the chamber.
     * @return This returns an ArrayList which contains all the monsters in the chamber.*/
    public Monster getMonster() { // Basically for other classes to access

        return myMonster;
    }

    /**This function adds the treasure that was generated by the chamber.
     * @param theTreasure This is the treasure object that is generated in chamber contents.*/
    private void addTreasure(Treasure theTreasure) {

        myTreasure = theTreasure; // Only allow one treasure chest for this assignment
    }

    /**This function retrieves the treasure that's in the chamber.
     * @return This returns a Treasure object which contains all the treasures in the chamber.*/
    public Treasure getTreasure() { // Basically for other classes to access

        return myTreasure;
    }

    /**This function gets the description of the entire passage.
     * @return Returns the string description of the passage.*/
    @Override
    public String getDescription() {
        // Might have to combine a bunch of strings from treasure, traps, chamberContents, shape, etc. here

        return getShapeAndSizeGenString() + getChamberContentsDescString();
    }

    /**This function adds the door that's passed from chamber into door array of passage.
     * @param newDoor This is the door that sent from passage.*/
    @Override
    public void setDoor(Door newDoor) {
        //should add a door connection to this room
        // This door connection comes from passageSection
        myDoors.add(newDoor); // This makes the entrance door first when added last
        newDoor.setConnection(this);
    }

    /*-----------
    You can write your own methods too, you aren't limited to the required ones
    ------------*/
//    /**This function is for adding passage door that will be connecting passage to chamber.
//     * @param newDoor This is the door that is being passed from passage to chamber.*/
//    public void setEntryDoor(Door newDoor) {
//        myDoors.add(0, newDoor);
//        newDoor.setConnection(this);
//    }

    private void chamberContentsGen() {
        StringBuilder descString = new StringBuilder();

        switch (myContents.getDescription()) {
            case "monster only":
                descString.append(monstersGen());
                break;
            case "monster and treasure":
                descString.append(monstersGen());
                descString.append(treasureGen());
                break;
            case "stairs":
                descString.append(stairsGen());
                break;
            case "trap":
                descString.append(trapGen());
                break;
            case "treasure":
                descString.append(treasureGen());
                break;
            default:
                descString.append("The chamber is empty.\n");
                break;
        }

        chamberContentsDescString = descString.toString();
    }

    /**This function generates treasure for a chamber, and displays what it is, what it's inside and who's guarding it.
     * @return Returns a string containing the treasure that was generated.*/
    private String treasureGen() {
        Treasure treasureChest = new Treasure();
        StringBuilder treasureString = new StringBuilder();

        treasureChest.chooseTreasure(d20.roll());
        treasureChest.setContainer(d20.roll());

        treasureString.append("(Treasure): ");

        if (!treasureChest.getContainer().equalsIgnoreCase("loose")) {
            treasureString.append(treasureChest.getDescription()).append(" inside ");
            treasureString.append(treasureChest.getContainer()).append(".\n"); // *Treasure* inside *container*
        } else { // If container is loose
            treasureString.append(treasureChest.getContainer()).append(" ").append(treasureChest.getDescription()).append(".\n"); // *Loose* *treasure*
        }

        try {
            treasureString.append("The treasure is guarded by ").append(treasureChest.getProtection()).append(".\n");
        } catch (NotProtectedException e) {
            treasureString.append("The treasure is unguarded!\n");
        }

        addTreasure(treasureChest);
        return treasureString.toString();
    }

    /**This function generates the shape and size of the chamber.
     * Refactored this code by splitting some functionality to createDoors.*/
    private void shapeAndSizeGen() {
        StringBuilder shapeAndSizeString = new StringBuilder();

        do {
            chamberShapeSize.setNumExits(d20.roll());
        } while (chamberShapeSize.getNumExits() > 4); // Prevent more doors than chambers.

        try {
            shapeAndSizeString.append("The chamber is ").append(chamberShapeSize.getShape()).append(", ").append(chamberShapeSize.getLength()).append(" ft long by ").append(chamberShapeSize.getWidth()).append(" ft wide with an area of ").append(chamberShapeSize.getArea()).append(" sq. ft.\n");
            if (chamberShapeSize.getNumExits() > 1) {
                shapeAndSizeString.append("There are ").append(chamberShapeSize.getNumExits()).append(" exits.\n");
            } else if (chamberShapeSize.getNumExits() == 1) {
                shapeAndSizeString.append("There is ").append(chamberShapeSize.getNumExits()).append(" exit.\n");
            } else {
                shapeAndSizeString.append("There are no other doors.\n");
            }
        } catch (UnusualShapeException e) {
            shapeAndSizeString.append("with an area of ").append(chamberShapeSize.getArea()).append(" sq. ft.\n");
            if (chamberShapeSize.getNumExits() > 1) {
                shapeAndSizeString.append("This chamber has ").append(chamberShapeSize.getNumExits()).append(" exits.\n");
            } else if (chamberShapeSize.getNumExits() == 1) {
                shapeAndSizeString.append("There is ").append(chamberShapeSize.getNumExits()).append(" exit.\n");
            } else {
                shapeAndSizeString.append("There are no other doors.\n");
            }
        }
        createDoors();

        shapeAndSizeGenString = shapeAndSizeString.toString();
    }

    private void createDoors() {

        for (int i = 0; i < chamberShapeSize.getNumExits(); i++) {
            Door chamberDoor = new Door(i + 1);
            setDoor(chamberDoor);
        }
    }

    /**This function generates stairs for the chamberContentGen function.
     * @return Returns a string of the stairs that were generated for the chamber.*/
    private String stairsGen() { // Optional method
        Stairs stairs = new Stairs();
        stairs.setType(d20.roll());


        return "(Stairs): There are stairs that go " + stairs.getDescription() + "\n";
    }

    /**This function generates traps for the chamberContentGen function.
     * @return Returns a string of the traps that were generated in the chamber.*/
    private String trapGen() { // Optional method
        Trap traps = new Trap();
        traps.chooseTrap(d20.roll());

        return "(Trap): " + traps.getDescription() + ".\n";
    }

    /**This function generates monsters for the chamberContentGen function.
     * @return Returns a string of the monster that was generated in the chamber.*/
    private String monstersGen() {
        Monster monsters = new Monster();
        monsters.setType(d20.roll());
        addMonster(monsters);

        return "(Monster): There are " + monsters.getMinNum() + " to " + monsters.getMaxNum() + " " + monsters.getDescription() + ".\n";

    }

    /**This function updates the description that is set for this chamber.*/
    private void setDescription() {
        chamberContentsGen();
        shapeAndSizeGen();
    }

    private String getChamberContentsDescString() {
        // Pretty much gonna be used to check for
        return chamberContentsDescString;
    }

    private String getShapeAndSizeGenString() {

        return shapeAndSizeGenString;
    }

    /**This function gets a door from all the doors, if any, the chamber contains.
     * @param i Index of door from all the doors.
     * @return Returns null if there's no door/doesn't exist or the door object specified.*/
    public Door getDoor(int i) {
        try {
            return myDoors.get(i);
        } catch (IndexOutOfBoundsException e) {
            return null;
        }
    }

}
